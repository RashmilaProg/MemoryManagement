C++ Memory Management ‚Äì Interview Questions and Detailed Answers





1. What are the different types of memory used in C++?


Answer:

C++ uses several memory segments:

‚Ä¢	Stack:

o	Stores local variables and function call data.
o	Managed automatically (LIFO).
o	Fast, but limited size.
‚Ä¢	
‚Ä¢	Heap (Free Store):

o	Dynamic memory allocated via new / malloc.
o	Managed manually (you must delete/free).
o	Larger than stack, but slower.
‚Ä¢	
‚Ä¢	Static/Global:

o	Stores global, static variables.
o	Exists for the lifetime of the program.
‚Ä¢	
‚Ä¢	Code/Text:

o	Stores compiled instructions.
‚Ä¢	
‚Ä¢	Constant Segment:

o	Stores read-only data like string literals.
‚Ä¢	





2. What‚Äôs the difference between new/delete and malloc/free?


Answer:
Feature	new / delete	malloc / free
Allocation	Type-safe, returns typed ptr	Returns void*
Constructor	Calls constructor	Doesn‚Äôt call constructor
Deallocation	Calls destructor	Doesn‚Äôt call destructor
Usage	C++ preferred	Legacy C, C-style code
Use new/delete in C++ as they support constructors/destructors and type safety.




3. What is a memory leak? How do you detect and prevent it?


Answer:

A memory leak happens when dynamically allocated memory is never released.
int* ptr = new int[10];
// no delete => memory leak

‚Ä¢	Detection Tools:

o	Valgrind (Linux)
o	AddressSanitizer (-fsanitize=address)
o	Visual Leak Detector (Windows)
‚Ä¢	
‚Ä¢	Prevention:

o	Use RAII.
o	Use smart pointers like std::unique_ptr, std::shared_ptr.
o	Avoid raw new/delete unless absolutely necessary.
‚Ä¢	





4. What is RAII? How does it help manage memory?


Answer:

RAII (Resource Acquisition Is Initialization) is a C++ idiom where resource management is tied to object lifetime.

‚Ä¢	Resource (memory, file, mutex) is acquired in constructor.
‚Ä¢	Released in destructor automatically.

class FileHandle {
    FILE* fp;
public:
    FileHandle(const char* filename) { fp = fopen(filename, "r"); }
    ~FileHandle() { if (fp) fclose(fp); }
};
Benefit: Eliminates memory leaks and manual cleanup.




5. What are smart pointers? How do they work?


Answer:

Smart pointers are classes that manage dynamic memory automatically.

‚Ä¢	std::unique_ptr<T>:

o	Exclusive ownership.
o	Cannot be copied.
‚Ä¢	

std::unique_ptr<int> p = std::make_unique<int>(10);

‚Ä¢	

‚Ä¢	std::shared_ptr<T>:

o	Shared ownership via reference count.
o	Automatically deletes when count = 0.
‚Ä¢	
‚Ä¢	std::weak_ptr<T>:

o	Observes shared_ptr without affecting reference count.
o	Prevents circular references.
‚Ä¢	


Use them instead of raw pointers.




6. Explain shallow vs deep copy in terms of memory.


Answer:

‚Ä¢	Shallow copy:

o	Copies pointer address.
o	Two pointers refer to same memory.
‚Ä¢	
‚Ä¢	Deep copy:

o	Allocates new memory.
o	Copies contents, avoids shared ownership.
‚Ä¢	

class A {
    int* data;
public:
    A(const A& other) {
        data = new int(*other.data); // deep copy
    }
    ~A() { delete data; }
};
Use deep copy if your class manages dynamic memory.




7. What is a dangling pointer and how can you prevent it?


Answer:

A dangling pointer is a pointer that refers to memory that has been freed.
int* ptr = new int(5);
delete ptr;
*ptr = 10; // undefined behavior!
Prevention:

‚Ä¢	Set pointer to nullptr after delete.
‚Ä¢	Use smart pointers to automatically manage object lifetime.





8. What is placement new in C++?


Answer:

Placement new constructs an object in pre-allocated memory.
char buffer[sizeof(MyClass)];
MyClass* obj = new (buffer) MyClass();
Use case:

‚Ä¢	Custom memory pools.
‚Ä¢	Embedded systems.
‚Ä¢	Avoiding heap allocations for performance.


Remember: You must manually call the destructor.




9. How does C++ handle memory when exceptions are thrown?


Answer:

‚Ä¢	Stack unwinding: Objects on the stack have their destructors called in reverse order.
‚Ä¢	Heap memory: Not automatically cleaned up unless wrapped in smart pointers or RAII.


Example:
void risky() {
    std::unique_ptr<int> p(new int);
    throw std::runtime_error("error"); // memory is automatically released
}
Avoid raw pointers when exceptions may occur.




10. How can you detect and debug memory issues in C++?


Answer:

‚Ä¢	Tools:

o	Valgrind: Memory leaks, invalid accesses (Linux).
o	AddressSanitizer: Compile-time detection (-fsanitize=address).
o	Visual Leak Detector / CRT Debug Heap: Windows.
‚Ä¢	
‚Ä¢	Manual techniques:

o	Overload new/delete to log allocations.
o	Use memory pool tracking.
‚Ä¢	





üîç BONUS Advanced Questions





11. What are custom allocators in STL?


Answer:

STL containers accept a custom allocator to control how memory is allocated/deallocated.
template <typename T>
struct MyAllocator : std::allocator<T> {
    // Custom allocation/deallocation logic
};
std::vector<int, MyAllocator<int>> v;
Used for:

‚Ä¢	Memory pools
‚Ä¢	Embedded systems
‚Ä¢	Real-time constraints





12. How do you manage memory in multithreaded programs?


Answer:

‚Ä¢	Use thread-safe allocators (e.g., tcmalloc, jemalloc).
‚Ä¢	Avoid shared ownership unless needed (prefer unique_ptr over shared_ptr).
‚Ä¢	Use std::atomic and mutexes if multiple threads access shared pointers.





13. What happens if you use delete on a pointer not allocated with new?


Answer:

‚Ä¢	Undefined Behavior.
‚Ä¢	The program might crash or corrupt memory.

int x;
int* ptr = &x;
delete ptr; // WRONG!
Always match:

‚Ä¢	new with delete
‚Ä¢	new[] with delete[]
‚Ä¢	Never delete stack or static memory





14. What is memory fragmentation?


Answer:

Memory fragmentation occurs when memory is allocated and freed in such a way that free memory blocks become non-contiguous.

‚Ä¢	Leads to inefficient use of memory.
‚Ä¢	Can‚Äôt allocate large blocks even if total free memory is enough.


Solution:

‚Ä¢	Use memory pools or compacting allocators.
‚Ä¢	Pre-allocate and reuse memory blocks.





15. When would you overload new and delete?


Answer:

To:

‚Ä¢	Track allocations (for debugging/leak detection).
‚Ä¢	Implement custom memory pools.
‚Ä¢	Log memory usage per class.

void* operator new(std::size_t size) {
    std::cout << "Allocating " << size << " bytes\n";
    return malloc(size);
}
You must also overload operator delete.


